<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>My first Three.js app</title>
		<style>
			body { margin: 0px; padding: 0px; overflow:hidden; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script>
			//
			// Cube geometry
			//
			//   4+--------+7
			//   /|       /|
			// 5+--------+6|
			//  | |      | |
			//  |0+------|-+3
			//  |/       |/
			// 1+--------+2
			//
			var cube_vertices = [
				[-1.0, -1.0, -1.0],
				[ 1.0, -1.0, -1.0],
				[ 1.0,  1.0, -1.0],
				[-1.0,  1.0, -1.0],
				[-1.0, -1.0,  1.0],
				[ 1.0, -1.0,  1.0],
				[ 1.0,  1.0,  1.0],
				[-1.0,  1.0,  1.0]
			];
			var cube_faces = [
				[0, 3, 2, 1],
				[0, 1, 5, 4],
				[1, 2, 6, 5],
				[2, 3, 7, 6],
				[3, 0, 4, 7],
				[4, 5, 6, 7]
			];
			// Pyramid geometry
			var pyramid_vertices = [
				[-1.0, -1.0,  0.0],
				[ 1.0, -1.0,  0.0],
				[ 1.0,  1.0,  0.0],
				[-1.0,  1.0,  0.0],
				[ 0.0,  0.0,  1.0]
			];
			var pyramid_faces = [
				[0, 3, 2, 1],
				[0, 1, 4],
				[1, 2, 4],
				[2, 3, 4],
				[3, 0, 4]
			];

			// Function for creating geometry
			function create_geometry (vertices, faces) {
				// Create geometry (cube primitive) in simple way
				// var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				// Create geometry (cube) in more complicted way
				var geometry = new THREE.Geometry();
				// Add vertices to geometry
				for (var i = 0; i < vertices.length; i++) {
					geometry.vertices.push(
						new THREE.Vector3(
							vertices[i][0],
							vertices[i][1],
							vertices[i][2]
							)
						);
				};
				// Add faces to geometry
				for (var i = 0; i < faces.length; i++) {
					// Triangle
					if(faces[i].length === 3) {
						geometry.faces.push(
							new THREE.Face3(
								faces[i][0],
								faces[i][1],
								faces[i][2]
								)
							);
					// Quad
					} else if (faces[i].length === 4) {
						//
						// 0 +--+ 3
						//   |\ |
						//   | \|
						// 1 +--+ 2
						//
						geometry.faces.push(
							new THREE.Face3(
								faces[i][0],
								faces[i][1],
								faces[i][2]
								)
							);
						geometry.faces.push(
							new THREE.Face3(
								faces[i][0],
								faces[i][2],
								faces[i][3]
								)
							);
					}
				};
				// Recompute normal vectors of faces
				geometry.computeFaceNormals();
				// Compute bounding box of geometry
				geometry.computeBoundingBox();

				return geometry;
			}

			// Create scene
			var scene = new THREE.Scene();

			// Create camera used for rendering scene
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.x = 0.0;
			camera.position.y = 0.0;
			camera.position.z = 5.0;

			// Create trackball control
			controls = new THREE.TrackballControls( camera );

			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;

			controls.keys = [ 65, 83, 68 ];

			controls.addEventListener( 'change', render );

			// Create renderer
			var renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			// Crete geometry from array of vertices and faces
			geometry = create_geometry(cube_vertices, cube_faces);
			//geometry = create_geometry(pyramid_vertices, pyramid_faces);

			// Create simple material
			var material = new THREE.MeshLambertMaterial( { color: 0x00aa00 } );
			// Create object from geometry and material
			var cube = new THREE.Mesh( geometry, material );
			// Add cube to the scene
			scene.add( cube );

			// Create a point light
			var pointLight1 = new THREE.PointLight( 0xFFFFFF );
			pointLight1.position.x = camera.position.x + 0.1;
			pointLight1.position.y = camera.position.y + 0.1;
			pointLight1.position.z = camera.position.z + 1.0;
			// Add light to the scene
			scene.add( pointLight1 );

			// Create a point light
			var pointLight2 = new THREE.PointLight( 0xAAAAFF );
			pointLight2.position.x = camera.position.x - 2.0;
			pointLight2.position.y = camera.position.y - 2.0;
			pointLight2.position.z = camera.position.z - 6.0;
			// Add light to the scene
			scene.add( pointLight2 );

			// Callback function for resizing winoow
			window.onresize = function(event) {
				// Update camera
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				// Update renderer
				renderer.setSize( window.innerWidth, window.innerHeight);

				controls.handleResize();
			};

			function animate() {
				requestAnimationFrame( animate );
				// Update position of camera
				controls.update();
				// Update position of 1st light
				pointLight1.position.x = camera.position.x + 0.1;
				pointLight1.position.y = camera.position.y + 0.1;
				pointLight1.position.z = camera.position.z + 1.0;
				// Update position of 2nd light
				pointLight2.position.x = camera.position.x - 2.0;
				pointLight2.position.y = camera.position.y - 2.0;
				pointLight2.position.z = camera.position.z - 6.0;
				
				render();
			};

			function render() {
				renderer.render( scene, camera );
			};

			render();
			animate();

		</script>
	</body>
</html>
